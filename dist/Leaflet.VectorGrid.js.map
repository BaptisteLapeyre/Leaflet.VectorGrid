{"version":3,"file":"Leaflet.VectorGrid.js","sources":["../src/Leaflet.VectorGrid.Protobuf.js","../src/Leaflet.VectorGrid.Slicer.js","../src/Leaflet.VectorGrid.js","../src/Leaflet.Renderer.Canvas.Tile.js","../src/Leaflet.Renderer.SVG.Tile.js"],"sourcesContent":["\n// Network & Protobuf powered!\n// NOTE: Assumes the globals `VectorTile` and `Pbf` exist!!!\nL.VectorGrid.Protobuf = L.VectorGrid.extend({\n\n\toptions: {\n\t\tsubdomains: 'abc',\t// Like L.TileLayer\n\t},\n\n\n\tinitialize: function(url, options) {\n\t\t// Inherits options from geojson-vt!\n// \t\tthis._slicer = geojsonvt(geojson, options);\n\t\tthis._url = url;\n\t\tL.VectorGrid.prototype.initialize.call(this, options);\n\t},\n\n\n\t_getSubdomain: L.TileLayer.prototype._getSubdomain,\n\n\n\t_getVectorTilePromise: function(coords) {\n\t\tvar tileUrl = L.Util.template(this._url, L.extend({\n\t\t\ts: this._getSubdomain(coords),\n\t\t\tx: coords.x,\n\t\t\ty: coords.y,\n\t\t\tz: coords.z\n// \t\t\tz: this._getZoomForUrl()\t/// TODO: Maybe replicate TileLayer's maxNativeZoom\n\t\t}, this.options));\n\n\t\treturn fetch(tileUrl).then(function(response){\n\n\t\t\tif (!response.ok) {\n\t\t\t\treturn {layers:[]};\n\t\t\t}\n\n\t\t\treturn response.blob().then( function (blob) {\n// \t\t\t\tconsole.log(blob);\n\n\t\t\t\tvar reader = new FileReader();\n\t\t\t\treturn new Promise(function(resolve){\n\t\t\t\t\treader.addEventListener(\"loadend\", function() {\n\t\t\t\t\t\t// reader.result contains the contents of blob as a typed array\n\n\t\t\t\t\t\t// blob.type === 'application/x-protobuf'\n\t\t\t\t\t\tvar pbf = new Pbf( reader.result );\n// \t\t\t\t\t\tconsole.log(pbf);\n\t\t\t\t\t\treturn resolve(new vectorTile.VectorTile( pbf ));\n\n\t\t\t\t\t});\n\t\t\t\t\treader.readAsArrayBuffer(blob);\n\t\t\t\t});\n\t\t\t});\n\t\t}).then(function(json){\n\n// \t\t\tconsole.log('Vector tile:', json.layers);\n// \t\t\tconsole.log('Vector tile water:', json.layers.water);\t// Instance of VectorTileLayer\n\n\t\t\t// Normalize feature getters into actual instanced features\n\t\t\tfor (var layerName in json.layers) {\n\t\t\t\tvar feats = [];\n\n\t\t\t\tfor (var i=0; i<json.layers[layerName].length; i++) {\n\t\t\t\t\tvar feat = json.layers[layerName].feature(i);\n\t\t\t\t\tfeat.geometry = feat.loadGeometry();\n\t\t\t\t\tfeats.push(feat);\n\t\t\t\t}\n\n\t\t\t\tjson.layers[layerName].features = feats;\n\t\t\t}\n\n\t\t\treturn json;\n\t\t});\n\t}\n});\n\n\nL.vectorGrid.protobuf = function (url, options) {\n\treturn new L.VectorGrid.Protobuf(url, options);\n};\n\n","\n\n\n// geojson-vt powered!\n// NOTE: Assumes the global `geojsonvt` exists!!!\nL.VectorGrid.Slicer = L.VectorGrid.extend({\n\n\toptions: {\n\t\tvectorTileLayerName: 'sliced',\n\t\textent: 4096\t// Default for geojson-vt\n\t},\n\n\tinitialize: function(geojson, options) {\n\t\tL.VectorGrid.prototype.initialize.call(this, options);\n\n\n\t\tthis._slicers = {};\n\t\tif (geojson.type && geojson.type === 'Topology') {\n\t\t\t// geojson is really a topojson\n\t\t\tfor (var layerName in geojson.objects) {\n\t\t\t\tthis._slicers[layerName] = geojsonvt(\n\t\t\t\t\ttopojson.feature(geojson, geojson.objects[layerName])\n\t\t\t\t, this.options);\n\t\t\t}\n\t\t} else {\n\t\t\t// For a geojson, create just one vectortilelayer named with the value\n\t\t\t// of the option.\n\t\t\t// Inherits available options from geojson-vt!\n\t\t\tthis._slicers[this.options.vectorTileLayerName] = geojsonvt(geojson, this.options);\n\t\t}\n\n\t},\n\n\t_getVectorTilePromise: function(coords) {\n\n\t\tvar tileLayers = {};\n\n\t\tfor (var layerName in this._slicers) {\n\t\t\tvar slicer = this._slicers[layerName];\n\t\t\tvar slicedTileLayer = slicer.getTile(coords.z, coords.x, coords.y);\n\n\t\t\tif (slicedTileLayer) {\n\t\t\t\tvar vectorTileLayer = {\n\t\t\t\t\tfeatures: [],\n\t\t\t\t\textent: this.options.extent,\n\t\t\t\t\tname: this.options.vectorTileLayerName,\n\t\t\t\t\tlength: slicedTileLayer.features.length\n\t\t\t\t}\n\n\t\t\t\tfor (var i in slicedTileLayer.features) {\n\t\t\t\t\tvar feat = {\n\t\t\t\t\t\tgeometry: slicedTileLayer.features[i].geometry,\n\t\t\t\t\t\tproperties: slicedTileLayer.features[i].tags,\n\t\t\t\t\t\ttype: slicedTileLayer.features[i].type\t// 1 = point, 2 = line, 3 = polygon\n\t\t\t\t\t}\n\t\t\t\t\tvectorTileLayer.features.push(feat);\n\t\t\t\t}\n\n\t\t\t\ttileLayers[layerName] = vectorTileLayer;\n\t\t\t}\n\n\t\t}\n\n\t\treturn new Promise(function(resolve){ return resolve({ layers: tileLayers })});\n\t},\n\n});\n\n\nL.vectorGrid.slicer = function (geojson, options) {\n\treturn new L.VectorGrid.Slicer(geojson, options);\n};\n\n","\n\nL.VectorGrid = L.GridLayer.extend({\n\n\toptions: {\n\t\trendererFactory: L.svg.tile,\n\t\tvectorTileLayerStyles: {}\n\t},\n\n\tcreateTile: function(coords, done) {\n\t\tvar renderer = this.options.rendererFactory(this.getTileSize(), this.options);\n\n\t\tvar vectorTilePromise = this._getVectorTilePromise(coords);\n\n\n\t\tvectorTilePromise.then( function(vectorTile) {\n\n\t\t\tfor (var layerName in vectorTile.layers) {\n\t\t\t\tvar layer = vectorTile.layers[layerName];\n\n\t\t\t\t/// NOTE: THIS ASSUMES SQUARE TILES!!!!!1!\n\t\t\t\tvar pxPerExtent = this.getTileSize().x / layer.extent;\n\n\t\t\t\tvar layerStyle = this.options.vectorTileLayerStyles[ layerName ] ||\n\t\t\t\tL.Path.prototype.options;\n\n\t\t\t\tfor (var i in layer.features) {\n\t\t\t\t\tvar feat = layer.features[i];\n\t\t\t\t\tthis._mkFeatureParts(feat, pxPerExtent);\n\n\t\t\t\t\t/// Style can be a callback that is passed the feature's\n\t\t\t\t\t/// properties and tile zoom level...\n\t\t\t\t\tvar styleOptions = (layerStyle instanceof Function) ?\n\t\t\t\t\tlayerStyle(feat.properties, coords.z) :\n\t\t\t\t\tlayerStyle;\n\n\t\t\t\t\tif (!(styleOptions instanceof Array)) {\n\t\t\t\t\t\tstyleOptions = [styleOptions];\n\t\t\t\t\t}\n\n\t\t\t\t\t/// Style can be an array of styles, for styling a feature\n\t\t\t\t\t/// more than once...\n\t\t\t\t\tfor (var j in styleOptions) {\n\t\t\t\t\t\tvar style = L.extend({}, L.Path.prototype.options, styleOptions[j]);\n\n\t\t\t\t\t\tif (feat.type === 1) { // Points\n\t\t\t\t\t\t\tstyle.fill = false;\n\t\t\t\t\t\t} else if (feat.type === 2) {\t// Polyline\n\t\t\t\t\t\t\tstyle.fill = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfeat.options = style;\n\t\t\t\t\t\trenderer._initPath( feat );\n\t\t\t\t\t\trenderer._updateStyle( feat );\n\n\t\t\t\t\t\tif (feat.type === 1) { // Points\n\t\t\t\t\t\t\t// \t\t\t\t\t\t\tstyle.fill = false;\n\t\t\t\t\t\t} else if (feat.type === 2) {\t// Polyline\n\t\t\t\t\t\t\tstyle.fill = false;\n\t\t\t\t\t\t\trenderer._updatePoly(feat, false);\n\t\t\t\t\t\t} else if (feat.type === 3) {\t// Polygon\n\t\t\t\t\t\t\trenderer._updatePoly(feat, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trenderer._addPath( feat );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tL.Util.requestAnimFrame(done);\n\t\t}.bind(this));\n\n\t\treturn renderer.getContainer();\n\t},\n\n\n\n\t// Fills up feat._parts based on the geometry and pxPerExtent,\n\t// pretty much as L.Polyline._projectLatLngs and L.Polyline._clipPoints\n\t// would do but simplified as the vectors are already simplified/clipped.\n\t_mkFeatureParts: function(feat, pxPerExtent) {\n\n\t\tvar rings = feat.geometry;\n\n\t\tfeat._parts = [];\n\t\tfor (var i in rings) {\n\t\t\tvar ring = rings[i];\n\t\t\tvar part = [];\n\t\t\tfor (var j in ring) {\n\t\t\t\tvar coord = ring[j];\n\t\t\t\tif ('x' in coord) {\n\t\t\t\t\t// Protobuf vector tiles return {x: , y:}\n\t\t\t\t\tpart.push(L.point(coord.x * pxPerExtent, coord.y * pxPerExtent));\n\t\t\t\t} else {\n\t\t\t\t\t// Geojson-vt returns [,]\n\t\t\t\t\tpart.push(L.point(coord[0] * pxPerExtent, coord[1] * pxPerExtent));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfeat._parts.push(part);\n\t\t}\n\n\t},\n\n});\n\n\n\nL.vectorGrid = function (options) {\n\treturn new L.VectorGrid(options);\n};\n\n\n\n","\n\nL.Canvas.Tile = L.Canvas.extend({\n\n\tinitialize: function (tileSize, options) {\n\t\tL.Canvas.prototype.initialize.call(this, options);\n\t\tthis._size = tileSize;\n\n\t\tthis._initContainer();\n\t\tthis._container.setAttribute('width', this._size.x);\n\t\tthis._container.setAttribute('height', this._size.y);\n\t\tthis._layers = {};\n\t\tthis._drawnLayers = {};\n\t},\n\n\tgetContainer: function() {\n\t\treturn this._container;\n\t},\n\n\tonAdd: L.Util.FalseFn,\n\n\t_initContainer: function () {\n\t\tvar container = this._container = document.createElement('canvas');\n\n// \t\tL.DomEvent\n// \t\t\t.on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)\n// \t\t\t.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)\n// \t\t\t.on(container, 'mouseout', this._handleMouseOut, this);\n\n\t\tthis._ctx = container.getContext('2d');\n\t},\n\n\n\t/// TODO: Modify _initPath to include an extra parameter, a group name\n\t/// to order symbolizers by z-index\n\n});\n\n\nL.canvas.tile = function(tileSize, opts){\n\treturn new L.Canvas.Tile(tileSize, opts);\n}\n\n","\n\nL.SVG.Tile = L.SVG.extend({\n\n\tinitialize: function (tileSize, options) {\n\t\tL.SVG.prototype.initialize.call(this, options);\n\t\tthis._size = tileSize;\n\n\t\tthis._initContainer();\n\t\tthis._container.setAttribute('width', this._size.x);\n\t\tthis._container.setAttribute('height', this._size.y);\n\t\tthis._container.setAttribute('viewBox', [0, 0, this._size.x, this._size.y].join(' '));\n\t},\n\n\tgetContainer: function() {\n\t\treturn this._container;\n\t},\n\n// \tonAdd: function() {},\n\tonAdd: L.Util.FalseFn,\n\n\t_initContainer: function() {\n\t\tL.SVG.prototype._initContainer.call(this);\n\t\tvar rect =  L.SVG.create('rect');\n\n// \t\trect.setAttribute('x', 0);\n// \t\trect.setAttribute('y', 0);\n// \t\trect.setAttribute('width', this._size.x);\n// \t\trect.setAttribute('height', this._size.y);\n// \t\trect.setAttribute('fill', 'transparent');\n// \t\trect.setAttribute('stroke', 'black');\n// \t\trect.setAttribute('stroke-width', 2);\n// \t\tthis._rootGroup.appendChild(rect);\n\t},\n\n\t/// TODO: Modify _initPath to include an extra parameter, a group name\n\t/// to order symbolizers by z-index\n\n\t_addPath: function (layer) {\n\t\tthis._rootGroup.appendChild(layer._path);\n\t},\n\n});\n\n\nL.svg.tile = function(tileSize, opts){\n\treturn new L.SVG.Tile(tileSize, opts);\n}\n\n"],"names":[],"mappings":"AIAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ADjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AD3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ADjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ADzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}